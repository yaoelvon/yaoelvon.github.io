{"meta":{"title":"技术洞见","subtitle":"疑而能问，已得知识之半。","description":"冯尧的博客，yaoel.com, 冯尧, fengyao","author":"冯尧","url":"http://yaofeng.org"},"pages":[{"title":"关于我","date":"2016-08-06T13:26:20.000Z","updated":"2017-05-06T09:47:51.000Z","comments":true,"path":"about/index.html","permalink":"http://yaofeng.org/about/index.html","excerpt":"","text":"90后，宅男，魔都某创业公司码农。技术栈：AngularJS+Nginx+Flask+MySQL+Docker+Linux 网站个人技术博客搭建采用Hexo+lightum主题网站托管在github和阿里云服务器 联系方式微博: 冯尧E-mail: yaoelvon@gmail.com"}],"posts":[{"title":"","slug":"traefik-http-server-closed-idle-connection","date":"2017-05-12T01:41:49.000Z","updated":"2017-05-12T01:41:49.000Z","comments":true,"path":"2017/05/12/traefik-http-server-closed-idle-connection/","link":"","permalink":"http://yaofeng.org/2017/05/12/traefik-http-server-closed-idle-connection/","excerpt":"","text":"关于traefik报：http: server closed idle connection问题的分析和解决现象软件新版本上线后，系统经常时不时的出现500 Internal Server Error和502问题。 探查下面是软件的大体架构1SLB&lt;----&gt;traefik&lt;---&gt;uwsgi&lt;----&gt;web server 请求从浏览器客户端发起，先到负载均衡，然后负载均衡转发到traefik，traefik再转发到具体的服务器某个端口；服务器端口后面是实际的web服务，当然，先通过uwsgi层再进入web server。当出现500 Internal Server Error时，去查看具体的请求，发现三个蛛丝马迹： 1.客户端同时发送了多个相同请求；2.在web server的日志中看不到对应的请求报文；3.traefik日志中出现：time=&quot;2017-03-20T03:43:17Z&quot; level=warning msg=&quot;Error forwarding to http://xx.xx.xx.xx:8888, err: http: server closed idle connection”错误；4.所有request headers和response headers中都带有Connection: keep-alive； 分析1.请求在traefik和uwsgi之间中断了；2.跟http的长连接有关系； 解决对于相同请求，第一个请求过来，带了Connection:keep-alive头，traefik认为跟uwsgi建立了长连接通道，但由于uwsgi没有支持长连接，在返回后就将连接关闭。单相同的第二个请求过来时，traefik还是使用之前的通道，而此时uwsgi已经关闭了连接，所以报错：http: server closed idle connection。 再来看系统中uwsgi.ini： 123456[uwsgi]......http-socket = 0.0.0.0:5000http-keepalive = 1add-header=Connection: Keep-Alive...... 虽然看上去设置了http-keepalive，但是由于http-socket不支持keep-alive，所以无用。正确的配置方式如下： 123456[uwsgi]......http = 0.0.0.0:5000http-keepalive = 1add-header=Connection: Keep-Alive...... 作者 @yaoel2017 年 05月 11日 参考1.Traefik sporadically failing when proxying requests2.uWSGI Options3.HTTP权威指南 4.5.6 Keep–Alive和哑代理4.http-socket does not support Keep-Alive5.uwsgi.ini配置参考","categories":[],"tags":[]},{"title":"","slug":"flask-migrate-mysql-rename-table-and-rename-field","date":"2017-05-12T01:41:43.000Z","updated":"2017-05-12T01:41:43.000Z","comments":true,"path":"2017/05/12/flask-migrate-mysql-rename-table-and-rename-field/","link":"","permalink":"http://yaofeng.org/2017/05/12/flask-migrate-mysql-rename-table-and-rename-field/","excerpt":"","text":"使用Flask-Migrate（alembic）实现MySQL表名修改、字段名修改和枚举类型修改 表名修改 字段名修改 枚举类型增加枚举可选值 表名修改由于之前创建的MySQL数据表名跟实际用处不符，所以需要修改表名，并保证数据不丢失。若直接修改表名，然后使用命令python manage.py db migrate会删除后新建，导致数据丢失。为了保证数据不丢失，可以自己使用alembic语法编写升级脚本。语法如下：1op.rename_table(&apos;shop_print_rules&apos;, &apos;label_print_rules&apos;) 字段名修改由于字段名名不副实，所以要对字段名进修改，并保证数据不丢失。若字节修改字段名，然后使用命令python manage.py db migrate会删除后新建，导致数据丢失。使用下列语法可以保证数据不丢失，但需要自己编写升级脚本。语法如下：1234op.alter_column(&apos;label_print_rules&apos;, &apos;box_template_type&apos;, new_column_name=&apos;template_type&apos;, existing_type=sa.Enum(&apos;single_box&apos;, &apos;all_box&apos;, &apos;pick&apos;, &apos;putaway&apos;, &apos;stockin&apos;, &apos;stockout&apos;, &apos;delivery&apos;) server_default=&apos;single_box&apos;) 枚举类型字段增加枚举可选值当对枚举类型字段增加枚举可选值时，使用Flask-Migrate进行migrate不会检测到改动，所以需要手动写脚本。语法如下：1234567op.alter_column(&apos;label_print_rules&apos;, &apos;template_type&apos;, existing_type=sa.Enum(&apos;single_box&apos;, &apos;all_box&apos;, &apos;pick&apos;, &apos;putaway&apos;, &apos;stockin&apos;, &apos;stockout&apos;, &apos;delivery&apos;), type_=sa.Enum(&apos;single_box&apos;, &apos;all_box&apos;, &apos;pick&apos;, &apos;putaway&apos;, &apos;stockin&apos;, &apos;stockout&apos;, &apos;delivery&apos;, &apos;single_picking_label&apos;, &apos;multi_picking_label&apos;, &apos;order_picking_label&apos;), server_default=&apos;single_box&apos;) 作者 @yaoel2017 年 05月 09日 参考：1.alembic.op.rename_table2.Flask-Migrate升级MySQL字段时能否重命名而非删除后新建","categories":[],"tags":[]},{"title":"","slug":"caddy-introduction","date":"2017-05-09T06:29:40.000Z","updated":"2017-05-09T06:29:40.000Z","comments":true,"path":"2017/05/09/caddy-introduction/","link":"","permalink":"http://yaofeng.org/2017/05/09/caddy-introduction/","excerpt":"","text":"caddy简介什么是caddy？一个类似Nginx的东西。最近在折腾将部署在github上的hexo博客迁移到自己的服务器上。偶然间知道了caddy这个神器，真的是一键部署博客。由于服务器是ubuntu 16.04版本的，下面是基于此版本进行的。 caddy的好处： 一键启动 一键https 各种方便的配置 下载到caddy官网下载页面下载对应版本。然后使用scp将压缩文件拷贝到自己服务器。 1scp ./caddy*.tar.gz root@xx.xx.xx.xx:/path/to/place/caddy***.tar.gz ##解压，然后将可执行文件拷贝在对应bin目录下（全局可运行） 12tar -xzf caddy*.tar.gz caddymv ./caddy /usr/local/bin 进入你的博客目录运行注意要有index.html文件，如果没有回报错 12cd /your/blog/pathcaddy 然后在服务器的2015端口就可访问博客。 ##配置域名 1.要讲yaofeng.org域名解析到对应服务器的ip地址；2.在此过程中会提示为你自动设置https，但是需要你输入此域名拥有者的登记邮箱。 1caddy -host yaofeng.org 看到123Activating privacy features... done.https://yaofeng.orghttp://yaofeng.org 表示https设置成功。 Caddyfile为了方便配置，可以将所有的配置信息都写入Caddyfile文件可以通过\"yaofeng.org\" > Caddyfile```达到上述一样的效果。1在运行caddy命令时，也可以通过-conf参数设置对应Caddyfile配置文件的所在目录：```caddy -conf ../path/to/Caddyfile 也可以在一个Caddyfile中设置多个域名的解析 1234567yaofeng.org &#123; root /www/yaofeng.org&#125;sub.yaofeng.org &#123; root /www/sub.yaofeng.org&#125; over","categories":[],"tags":[]},{"title":"docker启动镜像时，运行可执行文件报\"permission denied\"","slug":"docker-run-raise-exception-permission-denied","date":"2017-05-04T05:05:59.000Z","updated":"2017-05-07T08:36:31.000Z","comments":true,"path":"2017/05/04/docker-run-raise-exception-permission-denied/","link":"","permalink":"http://yaofeng.org/2017/05/04/docker-run-raise-exception-permission-denied/","excerpt":"","text":"错误信息：122017-04-28 17:38:20:docker: &#123;&quot;message&quot;:&quot;containerd: container not started&quot;&#125;2017-04-28 17:38:26:container_linux.go:247: starting container process caused &quot;exec: \\&quot;/IntelliJ/license_server\\&quot;: permission denied&quot; 解决方案：在Dockerfile中增加1RUN chmod +x ./license_server 参考：https://github.com/facebook/fbctf/issues/431","categories":[],"tags":[]},{"title":"ng-admin介绍","slug":"ng-admin-introduction","date":"2016-11-21T11:29:01.000Z","updated":"2017-05-06T09:47:51.000Z","comments":true,"path":"2016/11/21/ng-admin-introduction/","link":"","permalink":"http://yaofeng.org/2016/11/21/ng-admin-introduction/","excerpt":"","text":"写在前面：本文档翻译自ng-admin 0.91版本。 使用ng-admin配合RESTFul风格的后端API可以马上得到一个完整的管理界面，功能包括：数据表格（datagrid）、过滤器（filters）、复杂的表单控件（complex form widgets）、多模型关系（multi-model relationships）和仪表盘/概览（dashboard）。它不仅仅拥有简单的增删该查（CRUD）功能，在不影响其他开发进度的情况下，ng-admin能够很快帮助你构建一个复杂的图形用户界面。 在线例子(例子源码) 英文文档 安装当前的ng-admin版本（master分支）基于Angular.js 1.4。如果你需要兼容Angular 1.3，请使用ng-admin 0.9。 使用包管理工具npm或bower获取ng-admin： 123npm install ng-admin —save# 或bower install ng-admin —save 将库文件ng-admin.min.css和ng-admin.min.js添加到HTML中，然后在&lt;body&gt;&lt;/body&gt;中增加&lt;div ui-view&gt;，最后对admin进行配置： 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html lang=“en”&gt; &lt;head&gt; &lt;title&gt;My First Admin&lt;/title&gt; &lt;link rel=“stylesheet” href=“node_modules/ng-admin/build/ng-admin.min.css”&gt; &lt;/head&gt; &lt;body ng-app=“myApp”&gt; &lt;div ui-view&gt;&lt;/div&gt; &lt;script src=“node_modules/ng-admin/build/ng-admin.min.js”&gt;&lt;/script&gt; &lt;script type=“text/javascript”&gt; var myApp = angular.module(‘myApp’, [‘ng-admin’]); myApp.config([‘NgAdminConfigurationProvider’, function(NgAdminConfigurationProvider) &#123; var nga = NgAdminConfigurationProvider; // 创建一个管理应用 var admin = nga.application(‘My First Admin’); // 之后的更多配置 // ... // 将管理应用连接到DOM中，然后运行它 nga.configure(admin); &#125;]); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 入门（Getting Started）如果是初次接触ng-admin，请仔细阅读章节入门。 用法示例（Usage Examples） 在博客管理示例(源码)中，你能看到一个简单的配置，里面的实体（entities)有发帖(posts)、评论（comments)和标签（tags）。同时使用FakeRest在浏览器中模拟后端REST API。 Posters Galore demo (source) 是一个更完整的电子商务管理页面，包含自定义认证、页面、指令和模块，并使用WebPack组织良好。同时使用FakeRest在浏览器中模拟后端REST API。 配置参考（Configuration Reference）在ng-admin中，一个管理工具是由包含多个实体（entities)的应用组成。每个实体（entity)拥有5种视图，每个视图拥有很多字段（fields）。 12345678910111213application |-header |-menu |-dashboard |-entity[] |-creationView |-editionView |-deletionView |-showView |-listView |-field[] |-name |-type 有关更多详细信息，请参阅配置API参考专用章节。 提示:您在ng-admin项目中将找不到相关的类。 实际上，管理配置API有一个独立、框架无关的库，称为admin-config。 不要犹豫，浏览该库的代码以了解更多。 关联（Relationships）Ng-admin的读写视图实体之间支持‘关联’。它提供了特定的字段类型来实现这些‘关联’：reference, referenced_list, reference_many, 和 embedded_list。关联参考章节中使用例子描述了更多的字段类型。 另外，配置API参考章节的字段部分具有所有字段类型的列表。 菜单配置（Menu Configuration）默认情况下，ng-admin创建一个侧边栏菜单，每个实体有一个条目。 如果要自定义侧边栏（标签，图标，顺序，添加子菜单等），则必须手动定义菜单。 请参见菜单配置专用章节。 仪表板配置（Dashboard Configuration）ng-admin应用程序的主页被称为仪表板。 使用它向最终用户显示重要的信息，例如最新条目或图表。 请参阅仪表板配置专用章节。 定制API映射（Customizing the API Mapping）ng-admin对REST API所做的所有HTTP请求都是由Restangular执行的。 REST规范没有提供足够的详细信息来涵盖管理GUI的所有需求。 ng-admin对如何设计您的API进行了一些假设。 所有这些假设都可以通过Restangular的请求和响应拦截器来覆盖。 这意味着你不需要为了ng-admin而调整你的API; ng-admin可以适应任何REST API，这要归功于Restangular的灵活性。 请参阅定制API映射专用章节。 主题（Theming）你可以在不同的级别覆盖几乎所有ng-admin生成的HTML。 参见主题专门章节。 添加自定义页面（Adding Custom Pages）对于每个实体，ng-admin创建用于’创建’，’检索’，’更新’和’删除’（CRUD）此实体的必要页面。 当您需要在实体上实现更特定的操作时，您必须添加自定义页面，例如要求向一个电子邮件地址发送消息的页面。 如何路由到特定页面并在ng-admin布局中显示它？ 请参阅添加自定义页面专用章节。 添加自定义类型（Adding Custom Types）当您在REST API的响应信息和ng-admin之间映射字段时，您需要为其指定类型。 这个类型会确定如何显示和编辑这些数据。 自定义现有的ng-admin类型和添加新的ng-admin类型非常容易。 请参阅添加自定义类型专用章节。 生产准备（Getting Ready For Production）要构建具有所需依赖关系的ng-admin源，并获得关于性能提升的提示，请参阅生产准备专用章节。 信息（News）关于ng-admin（教程，插件，新版本等）的新闻，请按照marmelab博客。 您还应该观看gitHub上的ng-admin发布页面以获取有关新发布的公告以及完成更新日志。 支持（Support）Ng-admin是一个开源项目，并且社区越来越大。 您可以通过在以下任何渠道询求帮助： StackOverflow Gitter (live chat)](https://gitter.im/marmelab/ng-admin) 请尽可能多地提供上下文，包括和管理配置的代码段，以及您映射的API的响应。 贡献（Contributing）在您的特定环境中的使用ng-admin的反馈是有价值的，不要犹豫打开GitHub的issue提出任何你想问的问题。","categories":[{"name":"ng-admin","slug":"ng-admin","permalink":"http://yaofeng.org/categories/ng-admin/"}],"tags":[{"name":"ng-admin","slug":"ng-admin","permalink":"http://yaofeng.org/tags/ng-admin/"}]},{"title":"MySQL小贴士","slug":"some-tips-of-MySQL","date":"2016-09-11T12:21:56.000Z","updated":"2017-05-06T09:47:51.000Z","comments":true,"path":"2016/09/11/some-tips-of-MySQL/","link":"","permalink":"http://yaofeng.org/2016/09/11/some-tips-of-MySQL/","excerpt":"","text":"1.创建数据库时，一定要设置字符编码格式刚开始的使用mysql的小白（比如博主），经常会碰到这样的情况，将中文存入数据库后显示的都是？？，而且长度相同的中文就unique字段就会提示：duplicate（重复了）。WTF？到底发生了什么？以上就是博主从windows平台切到mac后，开始配置mysql环境时碰到的问题。花了几个晚上的时间，搜索stackoverflow等境外网站，在代码中创表时加上各种设置字符集的方法，还有修改电脑的本地配置文件，设置了一堆，愣是没有解决。。后来是被公司的倩神（纯爷么）一语惊醒：你数据库字符集设了没有？。。。。。。。。。我瞬间想到stackoverflow上的一个回答。。就是创建数据库时设置字符集的方法，当时看到了，但也仅仅是看到，就直接忽略过去（也有原因是英文的，没完全懂）。真的想哭，不多说了，上mysql命令。 （1）如果你是新创建数据库，可以使用一下方式设置1CREATE DATABASE 数据库名 DEFAULT CHARACTER SET UTF8 DEFAULT COLLATE utf8_general_ci; （2）如果你的数据库已经创建了，可以通过修改字符集的方式解决（不推荐，可能会引发不明确的问题）1ALTER DATABASE databasename CHARACTER SET utf8 COLLATE utf8_general_ci; 2.mysql数据库中的数据是可以被dump出来，随处恢复的就拿我所在的项目组来说吧，如果你要对系统进行流程测试。之前的做法是：初始化初始数据-》使用excel表格导入各种数据到系统中-》然后再开始测试。这样做有三个缺点：1.效率低；2.excel表格需要具有一致性，若某些数据被修改过，会导入失败；3.数据量小，无法完全暴露问题。现在有了dump神器，可以将某些客户的现场数据dump出来（当然，用户数据是不会外泄的，只是测试，只是测试，只是测试），直接在数据库中进行恢复。dump的方法如下：123time=$(date +%Y-%m-%dT%H:%M:%S)mysqldump -h &lt;服务器地址&gt; -P &lt;端口号&gt; -u &lt;用户名&gt; -p&lt;密码&gt; &lt;数据库名&gt; &gt; $time.dumpps:本地可以不填服务器地址，但是端口号要填，默认是3306（如果不填，dump命令会阻塞，ctrl-C 无法退出） 恢复方法如下：1mysql -h &lt;服务器地址&gt; -P &lt;端口号&gt; -u &lt;用户名&gt; -p &lt;数据库名称&gt; &lt; mysql.dump 3. 在mysql中如何复制一行数据，同时使用新的id插入到数据库中具体当时为什么需要这个功能，博主已经忘了，直接上命令1insert into my_table( col1, col2 ) select col1, col2 from my_table where pk_id=?; 4.在mac上，python代码连接MySQL时，提示No module named MySQLdb，怎么解决这个问题，你需要确认两件事。（1）代码中数据库连接的url需要特殊设置1SQLALCHEMY_DATABASE_URI = &apos;mysql+pymysql://.....&apos; （2）需要安装python中操作mysql的库1pip install mysql-python 5.安装mysql5.7.1的坑5.6以前的MySQL安装后，默认是没有密码的，第一次登录时设置密码。这是博主一贯以为的。但是在mac上安装5.7.1时，遇到了坑。因为新的版本中，密码是安装过程中弹窗告诉我们的。而当时，博主并没有关系什么弹窗，直接没看就关闭了。导致第一次登录一直提示密码错误。后来在网上某个csdn博客中讲到了这一点。然后博主就滚回去重装了。 6.其他一些常用的命令查看表的结构：show create table 表名;删除一行特定数据行：delete from 表名 where id = 1; 参考：1.mysql-copy-row-but-with-new-id2.No module named MySQLdb","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yaofeng.org/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yaofeng.org/tags/mysql/"}]},{"title":"使用angularjs时,如何配置所有的$http requests的headers,增加自定义信息?","slug":"custom-headers-of-request-at-AngularJS","date":"2016-08-06T08:25:25.000Z","updated":"2017-05-06T09:47:51.000Z","comments":true,"path":"2016/08/06/custom-headers-of-request-at-AngularJS/","link":"","permalink":"http://yaofeng.org/2016/08/06/custom-headers-of-request-at-AngularJS/","excerpt":"","text":"最近想要在前端所有的请求头中增加信息, 在实现过程中遇到了一些坑。下面记录了遇到的一些坑。如有疏漏,请轻喷~ 1.RestangularProvider.setDefaultHeaders和$http.defaults.headers.common[‘Authorization’]的区别 RestangularProvider.setDefaultHeaders只对使用Rectangular的请求有效；$http.defaults.headers.common对所有使用$http的请求有效；由于Rectangular底层用的也是$http，所以$http.defaults.headers.common对Restangular的请求也生效； 2.$http.defaults.headers.common[‘Authorization’]如何使用？123app.run([&apos;$http&apos;, function ($http) &#123; $http.defaults.headers.common[&apos;Authorization&apos;] = &apos;Basic d2VudHdvcnRobWFuOkNoYW5nZV9tZQ==&apos;;&#125;]); 存在问题：这个头部很容易丢失； 3.使用$http拦截器12345678910111213myapp.factory(&apos;httpRequestInterceptor&apos;, function () &#123; return &#123; request: function (config) &#123; config.headers[&apos;Authorization&apos;] = &apos;Basic d2VudHdvcnRobWFuOkNoYW5nZV9tZQ==&apos;; return config; &#125; &#125;;&#125;);myapp.config(function ($httpProvider) &#123; $httpProvider.interceptors.push(&apos;httpRequestInterceptor&apos;);&#125;); 4.使用angular-file-upload的坑当使用angular-file-upload进行数据导入时，使用httpRequestInterceptor在headers中增加Token信息是无效的；因为angular-file_upload不适用$http的服务，它使用原生的javascript XHR对象。或许未来会支持$http服务，但是现在并不支持。现在只能在upload对象上直接添加headers信息。12var uploader = new FileUploader();uploader.headers[&quot;Authorization&quot;] = &quot;Bearer &quot; + tokenInfo.accessToken; 5.推荐angularjs库①angular-jwt，帮助你在angularjs中使用JWT进行安全认证；②angular-file-upload，帮助你在angularjs中上传文件； 6.参考资料：1.RestangularProvider.setDefaultHeaders和$http.defaults.headers.common[‘Authorization’]有什么区别2.在angularjs中为所有的请求自定义headers3.在angular-file-upload中如何为request增加自定义的headers","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yaofeng.org/categories/javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yaofeng.org/tags/js/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yaofeng.org/tags/angularjs/"}]},{"title":"DNS原理入门","slug":"Introduction-to-DNS-principle","date":"2016-07-17T08:05:20.000Z","updated":"2017-05-06T09:47:51.000Z","comments":true,"path":"2016/07/17/Introduction-to-DNS-principle/","link":"","permalink":"http://yaofeng.org/2016/07/17/Introduction-to-DNS-principle/","excerpt":"","text":"DNS是互联网核心协议之一。 一、DNS是什么？DNS（Domain Name System）的作用非常简单，就是根据域名查出IP地址。你可以把它想象成一本巨大的电话本。 如果你想要访问域名fengyao.me，首先要通过DNS查出它的IP地址是192.30.252.154。 二、查询过程虽然只需要返回一个IP地址，但是DNS的查询过程非常复杂，分成多个步骤。工具dig可以显示整个查询过程。 1$dig fengyao.me 上面的命令会输出六段信息。 1234567891011121314151617181920212223242526272829; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; fengyao.me;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 1980;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: 6;; QUESTION SECTION:;fengyao.me. IN A;; ANSWER SECTION:fengyao.me. 3454 IN A 192.30.252.154fengyao.me. 3454 IN A 192.30.252.153;; AUTHORITY SECTION:fengyao.me. 86254 IN NS dns10.hichina.com.fengyao.me. 86254 IN NS dns9.hichina.com.;; ADDITIONAL SECTION:dns9.hichina.com. 3040 IN A 42.120.221.13dns9.hichina.com. 3040 IN A 140.205.81.13dns9.hichina.com. 3040 IN A 140.205.228.13dns10.hichina.com. 85275 IN A 140.205.81.23dns10.hichina.com. 85275 IN A 140.205.228.23dns10.hichina.com. 85275 IN A 42.120.221.23;; Query time: 6 msec;; SERVER: 192.168.3.1#53(192.168.3.1);; WHEN: Sun Jul 17 14:29:36 2016;; MSG SIZE rcvd: 206 第一段是查询参数和统计： 12345; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; fengyao.me;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 1980;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: 6 第二段是查询内容： 12;; QUESTION SECTION:;fengyao.me. IN A 上面结果显示，查询域名fengyao.me的A记录，A是address的缩写。 第三段是DNS服务器的答复。 123;; ANSWER SECTION:fengyao.me. 3454 IN A 192.30.252.154fengyao.me. 3454 IN A 192.30.252.153 上面结果显示，fengyao.me有两个A记录，即两个IP地址。3454是TTL值（Time to live的缩写），表示缓存时间，即3454秒之内不用重新查询。 第四段表示fengyao.me的NS记录（Name Server的缩写），即哪些服务器负责管理fengyao.me的DNS记录。 123;; AUTHORITY SECTION:fengyao.me. 86254 IN NS dns10.hichina.com.fengyao.me. 86254 IN NS dns9.hichina.com. 上面结果显示fengyao.me共有两条NS记录，即两个域名服务器，向其中任一台查询就知道fengyao.me的IP地址是什么。 第五段是上面两个域名服务器的IP地址，这是随着前一段一起返回的。 1234567;; ADDITIONAL SECTION:dns9.hichina.com. 3040 IN A 42.120.221.13dns9.hichina.com. 3040 IN A 140.205.81.13dns9.hichina.com. 3040 IN A 140.205.228.13dns10.hichina.com. 85275 IN A 140.205.81.23dns10.hichina.com. 85275 IN A 140.205.228.23dns10.hichina.com. 85275 IN A 42.120.221.23 第六段是DNS服务器的一些传输信息。 1234;; Query time: 6 msec;; SERVER: 192.168.3.1#53(192.168.3.1);; WHEN: Sun Jul 17 14:29:36 2016;; MSG SIZE rcvd: 206 上面的结果显示，本机的DNS服务器是192.168.3.1，查询端口是53（DNS服务器的默认端口），以及回应长度是206字节。 如果不想看这么多内容，可以使用+short参数： 123$ dig +short fengyao.me192.30.252.153192.30.252.154 上面命令只返回fengyao.me对应的两个IP地址（即A记录）。 三、DNS服务器下面我会根据前面这个例子，一步步还原，本机到底是怎么得到域名fengyao.me的IP地址。首先，本机一定要知道DNS服务器的IP地址，否则上不了网。通过DNS服务器，才能知道某个域名的IP地址到底是什么。 DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。Linux系统中里面，DNS服务器的IP地址保存在/etc/resolv.conf文件。 上面的DNS服务器是192.168.3.1，这是一个内网地址。有一些公网的DNS服务器，也可以使用，其中最有名的就是google的8.8.8.8和Level 3的4.2.2.2. 本机只向自己的DNS服务器查询，dig命令有一个@参数，显示向其他DNS服务器查询的结果。 1$ dig @4.2.2.2 fengyao.me 上面的指令向DNS服务器4.2.2.2查询： 123456789101112131415161718; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; @4.2.2.2 fengyao.me; (1 server found);; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 39511;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;fengyao.me. IN A;; ANSWER SECTION:fengyao.me. 600 IN A 192.30.252.153fengyao.me. 600 IN A 192.30.252.154;; Query time: 626 msec;; SERVER: 4.2.2.2#53(4.2.2.2);; WHEN: Sun Jul 17 14:45:27 2016;; MSG SIZE rcvd: 60 四、域名的层级DNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。请仔细看前面的例子，每个域名的尾部都多了一个点。 12;; QUESTION SECTION:;fengyao.me. IN A 比如，域名fengyao.me显示为fengyao.me.。这不是疏忽，而是所有域名的尾部，实际上都有一个根域名。 举例来说，www.example.com真正的域名是www.example.com.root，所以简写为www.example.com.。因为，根域名.root对于所有域名都是一样，所以平时是省略的。 根域名的下一级，叫做“顶级域名”（top-level domain，缩写为TLD），比如.com、.net、.me；再下一级叫做“次级域名”（second-level domain，缩写为SLD），比如www.example.com里面的.example，这一级域名是用户可以注册的；再下一级是主机名（host），比如www.example.com里面的www，又称为“三级域名”，这是用户在自己的域名里面为服务器分配的名字，是用户可以任意分配的。 总结一下，域名的层级结构如下： 123主机名.次级域名.顶级域名.根域名即host.sld.tld.root 五、根域名服务器DNS服务器根据域名的层次，进行分级查询。 需要明确的是，每一级域名都有自己的NS记录，NS记录指向该级域名服务器。这些服务器知道下一级域名的各种记录。 所谓’分级查询’，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下： 1231.从’根域名服务器’查到’顶级域名服务器’的NS记录和A记录（IP地址）2.从’顶级域名服务器’查到’次级域名服务器’的NS记录和A记录（IP地址）3.从’次级域名服务器’查出’主机名’的IP地址 仔细看上面的过程，没有提到DNS服务器怎么知道“根域名服务器”的IP地址。回答是“根域名服务器”的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。世界上一共有13组根域名服务器，从A.ROOT-SERVERS.NET一直到M.ROOT-SERVERS.NET 六、分级查询的实例dig命令的+trace参数可以显示DNS的整个分级查询过程。 1$dig +trace fengyao.me 上面命令的第一段列出根域名.的所有NS记录，即所有根域名服务器。 12345678910111213141516; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; +trace fengyao.me;; global options: +cmd. 51457 IN NS h.root-servers.net.. 51457 IN NS a.root-servers.net.. 51457 IN NS m.root-servers.net.. 51457 IN NS e.root-servers.net.. 51457 IN NS f.root-servers.net.. 51457 IN NS c.root-servers.net.. 51457 IN NS k.root-servers.net.. 51457 IN NS l.root-servers.net.. 51457 IN NS g.root-servers.net.. 51457 IN NS d.root-servers.net.. 51457 IN NS i.root-servers.net.. 51457 IN NS j.root-servers.net.. 51457 IN NS b.root-servers.net.;; Received 496 bytes from 192.168.3.1#53(192.168.3.1) in 80 ms 根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问fengyao.me的顶级域名服务器me.的NS记录。最先回复的根域名服务器将被缓存，以后只向这台服务器发请求。 接着是第二段： 123456789me. 172800 IN NS a0.cctld.afilias-nst.info.me. 172800 IN NS a2.me.afilias-nst.info.me. 172800 IN NS b0.cctld.afilias-nst.org.me. 172800 IN NS b2.me.afilias-nst.org.me. 172800 IN NS c0.cctld.afilias-nst.info.me. 172800 IN NS d0.cctld.afilias-nst.org.me. 172800 IN NS ns.nic.me.me. 172800 IN NS ns2.nic.me.;; Received 486 bytes from 198.97.190.53#53(198.97.190.53) in 468 ms 上面的结果显示.me域名有8条NS记录，同时返回的还有每一条记录对应的IP地址。 然后，DNS服务器向这些顶级域名发出查询请求，询问fengyao.me的次级域名fengyao.me的NS记录。 123fengyao.me. 86400 IN NS dns9.hichina.com.fengyao.me. 86400 IN NS dns10.hichina.com.;; Received 78 bytes from 89.188.44.44#53(89.188.44.44) in 324 ms 上面的结果显示fengyao.me有两条NS记录，同时返回的还有每一条NS记录对应的IP地址。 然后，DNS服务器向这两台NS服务器查询fengyao.me的主机名。 123fengyao.me. 600 IN A 192.30.252.154fengyao.me. 600 IN A 192.30.252.153;; Received 60 bytes from 140.205.228.13#53(140.205.228.13) in 4 ms 上面的结果显示，fengyao.me有两条A记录，即这两个IP地址都可以访问到网站，并且还表示，最先返回结果的NS服务器是140.205.228.13。 七、NS记录的查询dig命令可以单独查看每一级域名的NS记录。 12$dig ns me$dig ns fengyao.me +short参数可以显示简化的结果。 12$ dig +short ns me$ dig +short ns fengyao.me 八、DNS的记录类型域名与IP之间的对应关系，成为’记录’（record）。根据使用场景，“记录”可以分为不同的类型（type），前面已经看到了A记录和NS记录。 常见的DNS记录类型如下； 12345（1）A：地址记录（Address），返回域名指向的IP地址。（2）NS：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。（3）MX：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。（4）CNAME：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转，详见下页。（5）PRT：逆向查询记录（Pointer Record），只用于从IP地址查询域名，详见下页。 一般来说，为了服务的安全可靠，至少应该有两条NS记录，而A记录和MX记录也可能有多条，这样就提供了服务的冗余性，防止出现单点失败。 CNAME记录主要用于域名的内部跳转，为服务器配置提供灵活性，用户感知不到。举例来说，yaoelvon.github.io这个域名就是一个CNAME记录。 1234567891011121314151617181920$ dig yaoelvon.github.io; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; yaoelvon.github.io;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 8518;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;yaoelvon.github.io. IN A;; ANSWER SECTION:yaoelvon.github.io. 3600 IN CNAME github.map.fastly.net.github.map.fastly.net. 3600 IN CNAME prod.github.map.fastlylb.net.prod.github.map.fastlylb.net. 3600 IN A 151.101.100.133;; Query time: 768 msec;; SERVER: 192.168.3.1#53(192.168.3.1);; WHEN: Sun Jul 17 15:31:48 2016;; MSG SIZE rcvd: 126 上面结果显示，yaoelvon.github.io的CNAME指向github.map.fastly.net。也就是说，用户查询yaoelvon.github.io的时候，实际上返回的是github.map.fastly.net的IP地址。这样的好处是，变更服务器IP时，只要修改github.map.fastly.net这个域名就可以了，用户的yaoelvon.github.io域名不用修改。 由于CNAME记录就是一个替换，所以域名一旦设置CNAME记录后，就不能再设置其他记录了（比如A记录和MX记录），这是为了防止产生冲突。举例来说，foo.com指向bar.com，而两个域名各有自己的MX记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置MX记录，所以一般不允许用户对顶级域名设置CNAME记录。 PTR记录用于从IP地址反查域名。dig命令的-x参数用于查询PTR记录。 1234dig -x 192.30.252.153...;; ANSWER SECTION:153.252.30.192.in-addr.arpa. 3600 IN PTR pages.github.com. 上面的结果显示，192.30.252.153这台服务器的域名是pages.github.com。 逆向查询的一个应用，是可以防止垃圾邮件，即验证发送邮件的IP地址，是否真的有他所声称的域名。 dig命令可以查看指定的记录类型。 123$ dig a github.com$ dig ns github.com$ dig mx github.com 九、其他DNS工具除了dig，还有一些其他的小工具可以使用。（1）host命令host命令可以看做dig命令的简化版本，返回当前请求域名的各种记录。 12345$ host fengyao.mefengyao.me has address 192.30.252.154fengyao.me has address 192.30.252.153fengyao.me mail is handled by 10 mxw.mxhichina.com.fengyao.me mail is handled by 10 mxn.mxhichina.com. host也可用于逆向查询，即从IP地址查询域名，等同于dig -x 。 12$ host 192.30.252.153153.252.30.192.in-addr.arpa domain name pointer pages.github.com. （2）nslookup命令nslookup命令用于互动式地查询域名记录。 1234567891011$ nslookup&gt; fengyao.meServer: 192.168.3.1Address: 192.168.3.1#53Non-authoritative answer:Name: fengyao.meAddress: 192.30.252.154Name: fengyao.meAddress: 192.30.252.153&gt; （3）whois命令whois命令用来查询域名的注册情况。 十、参考 DNS原理入门–阮一峰","categories":[{"name":"NET","slug":"NET","permalink":"http://yaofeng.org/categories/NET/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"http://yaofeng.org/tags/DNS/"}]},{"title":"在flask中如何使用jinja2中的Flash来进行提示","slug":"how-to-use-flash-to-prompt-in-the-flash-jinja2","date":"2016-06-22T15:04:19.000Z","updated":"2017-05-06T09:47:51.000Z","comments":true,"path":"2016/06/22/how-to-use-flash-to-prompt-in-the-flash-jinja2/","link":"","permalink":"http://yaofeng.org/2016/06/22/how-to-use-flash-to-prompt-in-the-flash-jinja2/","excerpt":"","text":"jinja2模板中的写法123456789&#123;%- with messages = get_flashed_messages(with_categories=true) -%&#125;&#123;%- if messages -%&#125; &#123;%- for category, message in messages -%&#125; &lt;div class=&quot;alert alert-&#123;&#123; category &#125;&#125;&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/button&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &#123;%- endfor -%&#125;&#123;%- endif -%&#125; 调用方式12flash(&quot;用户名已存在&quot;, category=&apos;warning&apos;)flash(&quot;注册成功&quot;, category=&apos;success&apos;) category可选：’message’、’error’、’info’、’warning’、’success’ 参考： Flash","categories":[{"name":"flask","slug":"flask","permalink":"http://yaofeng.org/categories/flask/"},{"name":"jinja2","slug":"flask/jinja2","permalink":"http://yaofeng.org/categories/flask/jinja2/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yaofeng.org/tags/flask/"},{"name":"jinja2","slug":"jinja2","permalink":"http://yaofeng.org/tags/jinja2/"}]},{"title":"Flask-SQLALchemy动态的filter_by和filter","slug":"Flask-SQLALchemy-dynamic-filter-by-and-filter","date":"2016-06-05T02:16:29.000Z","updated":"2017-05-06T09:47:51.000Z","comments":true,"path":"2016/06/05/Flask-SQLALchemy-dynamic-filter-by-and-filter/","link":"","permalink":"http://yaofeng.org/2016/06/05/Flask-SQLALchemy-dynamic-filter-by-and-filter/","excerpt":"","text":"1.filter_byfilter_by用于查询简单的列名，不支持比较运算符。12filters = &#123;’name&apos;: ‘fengyao&apos;, ‘age&apos;: 26&#125;User.query.filter_by(**filters).first() 2.filter比filterby的功能更强大，支持比较运算符，支持or、in_等语法。12345filters = &#123; User.name == ‘fengyao’, User.age &gt; 25&#125;User.query.filter(*filters).first() 参考：1.SQLALchemy dynamic filter_by","categories":[{"name":"python","slug":"python","permalink":"http://yaofeng.org/categories/python/"}],"tags":[{"name":"Flask-SQLAlchemy","slug":"Flask-SQLAlchemy","permalink":"http://yaofeng.org/tags/Flask-SQLAlchemy/"}]},{"title":"使用Github SSH Key来避免Hexo部署时输入账户密码","slug":"use-git-ssh-key-carry-hexo-deploy","date":"2016-04-10T15:05:07.000Z","updated":"2016-04-10T15:05:07.000Z","comments":true,"path":"2016/04/10/use-git-ssh-key-carry-hexo-deploy/","link":"","permalink":"http://yaofeng.org/2016/04/10/use-git-ssh-key-carry-hexo-deploy/","excerpt":"","text":"前言当hexo使用https方式连接Github时，每次执行hexo deploy都会提示你输入账户和密码，不胜其烦。下面使用ssh连接方式可以免除每次输入账户密码的过程，而且安全可靠。如何使用github请看参考2。 操作修改_config.yml，将部署方式从https方式修改为ssh方式。123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/yaoelvon/yaoelvon.github.io.git branch: master 修改为123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:yaoelvon/yaoelvon.github.io.git branch: master 参考： 使用Github SSH Key以免去Hexo部署时输入密码 Git使用ssh协议授权","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yaofeng.org/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yaofeng.org/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://yaofeng.org/tags/git/"},{"name":"ssh","slug":"ssh","permalink":"http://yaofeng.org/tags/ssh/"}]},{"title":"个人博客计划","slug":"my-blog-plan","date":"2016-04-03T09:52:22.000Z","updated":"2016-04-04T14:16:22.000Z","comments":true,"path":"2016/04/03/my-blog-plan/","link":"","permalink":"http://yaofeng.org/2016/04/03/my-blog-plan/","excerpt":"","text":"从去年3月份开始，我就有了建设个人技术博客的想法。那时候，我是一个linux C嵌入式程序员。现在，已经成了一个初级全栈WEB程序员。不仅能用AngularJS写点前端代码，而且能用Python的Flask框架编写后端服务器代码。虽然现在我自认为还是一个菜鸟，但是为了成为技术大牛的梦想，我选择自己搭建一个技术博客。在建设个人技术博客的过程中，需要考虑两件事： 选择什么样的域名？ 博客用什么方式搭建？ 选择什么样的域名在选择域名方面，我相信很多人都纠结过。当然，我也是。刚开始我是想以自己名字的拼音注册域名的，但是fengyao.com和fengyao.cn都已经被注册了。然后就选择了我的网名，所以注册了yaoelvon.com。后来又觉得不好记。所以在不到一个月内，我注册了4个域名，分别是：yaoelvon.com、lessb.com、ipyjs.com和vincent.net.cn。下面是各个域名的优缺点。 yaoelvon 优点：我的网名、github账号、gmail账号；缺点：难记 lessb 优点：好记，可解释为lessbutbetter；缺点：sb ipyjs 优点：爱python javascript 缺点：面窄 vincent 优点：好记，英文名，冯申特 缺点：以.net.cn结尾 对于域名，我leader的建议是：重内容，轻域名。我网名注册的域名就挺好的。做公司才会对域名比较看重。我深以为然，但还是注册了好多域名。留着以后用吧。 另外可选的域名有：fengyao.me, 注册fengyao.me并使用。 2016/10/04 更换本博客的域名为yaofeng.org，并改名为【冯尧的博客】。2016/10/04 更换本博客的域名为yaoel.com。 博客用什么方式搭建据我所知，可以使用wordpress、jekll、hexo等方式建立博客。我没有使用过wordpress，所以不予评价。尝试过jekll，觉得不太好用。后来发现hexo挺好用的，而且zippera的博文写的很好，折腾了几次后，终于使用hexo将自己的博客搭建起来了。然而，使用hexo只是我搭建博客的第一步。我会逐渐对博客进行修改和重建。按照个人想法，最终决定将博客的建设分成4个阶段进行，这四个阶段都有代号，分别是：Monkey、Horse、Lion和Ape。下面是粗劣的设计方向： step1: MonkeyMonkey，意思是猴子，特点：灵巧。技术：使用hexo来实现，上线快，部署快，容易上手。参考：主要参考了Zippera的博文,在此对他表示感谢。 step2: HorseHorse，意思是马，特点：健壮。技术：使用Flask和Jinja实现，前端和服务器一体。参考：主要参考Flask Web开发。 step3: LionLion，意思是狮子。技术：前端改用AngularJS实现，后端使用Flask。参考：流程大致跟当前做的项目相同，参考当前项目。 step4: ApeApe，意思是猿，特点：聪明。（人猿星球出现在了我当前的脑海中）技术：AngularJS2.x或React做前端，后端使用Flask。参考：还没想好，待续。 时间计划下面是粗略的时间计划表： 时间 代号 2016/4/1-2016/5/31 Monkey 2016/6/1-2016/8/31 Horse 2016/9/1-2016/12/31 Lion 2017/1/1-2017/??/?? Ape 详细的计划会在独立的博文中出现。 fengyao","categories":[{"name":"BlogPlan","slug":"BlogPlan","permalink":"http://yaofeng.org/categories/BlogPlan/"}],"tags":[{"name":"博客计划","slug":"博客计划","permalink":"http://yaofeng.org/tags/博客计划/"}]}]}